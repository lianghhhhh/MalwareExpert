# Copyright (c) 2021 oalieno

import numpy
import torch
import torch.nn as nn
import click
import os
import r2pipe
import networkx as nx
import bin2asm

import sys
sys.path.append('./asm2vec/')
import datatype
import model
import utils

"""
@click.command()
@click.option('-i', '--input', 'ipath', help='target function', required=True)
@click.option('-m', '--model', 'mpath', help='model path', required=True)
@click.option('-e', '--epochs', default=10, help='training epochs', show_default=True)
@click.option('-n', '--neg-sample-num', 'neg_sample_num', default=25, help='negative sampling amount', show_default=True)
@click.option('-l', '--limit', help='limit the amount of output probability result', type=int)
@click.option('-c', '--device', default='auto', help='hardware device to be used: cpu / cuda / auto', show_default=True)
@click.option('-lr', '--learning-rate', 'lr', default=0.02, help="learning rate", show_default=True)
@click.option('-p', '--pretty', default=False, help='pretty print table', show_default=True, is_flag=True)
"""

def cli(ipath, mpath, epochs=10, neg_sample_num=25, device='auto', lr=0.02, pretty=False, limit=None):
    if device == 'auto':
        device = 'cuda' if torch.cuda.is_available() else 'cpu'

    # load model, tokens
    model, tokens = utils.load_model(mpath, device=device)
    functions, tokens_new, offset = utils.load_data(ipath)
    tokens.update(tokens_new)
    model.update(1, tokens.size())
    model = model.to(device)

    # train function embedding
    model = utils.train(
        functions,
        tokens,
        model=model,
        epochs=epochs,
        neg_sample_num=neg_sample_num,
        device=device,
        mode='test',
        learning_rate=lr
    )

    # show predicted probability results
    x, y = utils.preprocess(functions, tokens)
    #probs = model.predict(x.to(device), y.to(device))
    # convert to numpy array
    #probs = probs.detach().cpu().numpy()
    #utils.show_probs(x, y, probs, tokens, limit=limit, pretty=pretty)

    # get the final embedding of the input file
    embedding = model.get_embedding(x.to(device)) # the dim of the embedding is (embedding_size,)
    embedding = embedding.detach().cpu().numpy()

    #print(offset + ':')
    #print(embedding)
            
    return offset, embedding
    

if __name__ == '__main__':

    numpy.set_printoptions(threshold=sys.maxsize)
    if not os.path.exists("embedding"):
        os.mkdir("embedding")

    #dataset = 'dataset/' #binary files
    #for file in os.listdir(dataset):
    #    data = os.path.join(dataset, file)
    #    bin2asm.cli(data, 'test_asm/', 3)
        
    ipath = 'test_asm/' #asm files
    mpath = 'model.pt'

    dataset = 'dataset/' #binary files

    for file in os.listdir(ipath):  #asm files directory
        dir = os.path.join(ipath, file)

        for file in os.listdir(dataset): #binary files
            data = os.path.join(dataset, file)
            dir_temp = dir.split('/')[-1]
            data_temp = data.split('/')[-1]
            if dir_temp == data_temp:
                r2 = r2pipe.open(data)
                r2.cmd("aaa")
                r2.cmd("agCd > output.dot")

                # netwokx graph from dot string
                G = nx.nx_pydot.read_dot("output.dot")
                for file in os.listdir(dir):
                    file = os.path.join(dir, file)
                    offset, embedding = cli(file, mpath)

                    offset_temp = str(offset)[2:]
                    for i in range(8-len(offset_temp)):
                        offset_temp = '0' + offset_temp
                    offset_temp = '0x' + offset_temp

                    if G.has_node(offset_temp):
                        G.nodes[offset_temp]['embedding'] = embedding

                    """
                    #find the node in the graph and add the embedding to the node
                    for node in G.nodes():
                        node_temp = str(node)[2:]

                        #remove the 0 in the beginning
                        for i in range(len(node_temp)):
                            if node_temp[0] == '0':
                                node_temp = node_temp[1:]
                            else:
                                break
                        
                        if node_temp == offset_temp:
                            G.nodes[node]['embedding'] = embedding
                            break
                    """
                #output the graph
                nx.nx_pydot.write_dot(G, "embedding/{}.dot".format(data_temp))
                break


                
