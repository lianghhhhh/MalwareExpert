# Copyright (c) 2021 oalieno

import numpy
import torch
import torch.nn as nn
import os
import r2pipe
import networkx as nx
import bin2asm

import sys
sys.path.append('./asm2vec/')
import datatype
import model
import utils

#import subDetector from parent directory
parend_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))
sys.path.append(parend_dir)
from subDetector import subDetector


def cli(ipath, mpath, epochs=30, neg_sample_num=25, device='auto', lr=0.02, pretty=False, limit=None):
    if device == 'auto':
        device = 'cuda' if torch.cuda.is_available() else 'cpu'

    # load model, tokens
    model, tokens = utils.load_model(mpath, device=device)
    functions, tokens_new, offset = utils.load_data(ipath)
    tokens.update(tokens_new)
    model.update(1, tokens.size())
    model = model.to(device)


    # train function embedding
    model = utils.train(
        functions,
        tokens,
        model=model,
        epochs=epochs,
        neg_sample_num=neg_sample_num,
        device=device,
        mode='test',
        learning_rate=lr
    )

    # show predicted probability results
    x, y = utils.preprocess(functions, tokens)
    #probs = model.predict(x.to(device), y.to(device))
    # convert to numpy array
    #probs = probs.detach().cpu().numpy()
    #utils.show_probs(x, y, probs, tokens, limit=limit, pretty=pretty)

    # get the final embedding of the input file
    embedding = model.get_embedding(x.to(device)) # the dim of the embedding is (embedding_size,)
    embedding = embedding.detach().cpu().numpy()

    #print(offset + ':')
    #print(embedding)
            
    return offset, embedding
    

if __name__ == '__main__':

    numpy.set_printoptions(threshold=sys.maxsize)
    os.makedirs(subDetector().config.folder.vectorize, exist_ok=True)
        
    ipath = subDetector().config.folder.feature #asm files directory
    mpath = subDetector().config.path.asm2vec_model #model path

    dataset = subDetector().config.folder.dataset #binary files
    print(f'ipath: {ipath}')
    print(f'mpath: {mpath}')
    print(f'dataset: {dataset}')
    print(f'vectorize: {subDetector().config.folder.vectorize}')

    for folder in os.listdir(ipath):  #asm files directory
        temp_dir = os.path.join(ipath, folder)

        for dir in os.listdir(temp_dir): #asm files (because train part, one more directory level)
            dir = os.path.join(temp_dir, dir)
            print(f'now vectorize: {dir}')
            for file in os.listdir(dataset): #binary files
                data = os.path.join(dataset, file)
                dir_temp = dir.split('/')[-1]
                data_temp = data.split('/')[-1]
                if dir_temp == data_temp:
                    r2 = r2pipe.open(data)
                    r2.cmd("aaa")
                    r2.cmd("agCd > output.dot")

                    # netwokx graph from dot string
                    G = nx.nx_pydot.read_dot("output.dot")
                    try:
                        for file in os.listdir(dir):
                            file = os.path.join(dir, file)
                            offset, embedding = cli(file, mpath)

                            offset_temp = str(offset)[2:]
                            for i in range(8-len(offset_temp)):
                                offset_temp = '0' + offset_temp
                            offset_temp = '0x' + offset_temp

                            #find the node in the graph and add the embedding to the node
                            if G.has_node(offset_temp):
                                G.nodes[offset_temp]['embedding'] = embedding
                    except:
                        with open("error.txt", "a") as f:
                            f.write(dir + '\n')
                        print(f'error in {dir}')

                    #output the graph
                    nx.nx_pydot.write_dot(G, subDetector().config.folder.vectorize+"{}.dot".format(data_temp))
                    break

