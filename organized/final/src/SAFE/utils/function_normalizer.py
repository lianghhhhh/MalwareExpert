# @inproceedings{massarelli2018safe,
#   title={SAFE: Self-Attentive Function Embeddings for Binary Similarity},
#   author={Massarelli, Luca and Di Luna, Giuseppe Antonio and Petroni, Fabio and Querzoni, Leonardo and Baldoni, Roberto},
#   booktitle={Proceedings of 16th Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA)},
#   year={2019}
# }

import numpy as np

class FunctionNormalizer:
    """
    A class for normalizing function representations to a fixed length.
    """
    def __init__(self, max_instruction):
        """
        Initialize the FunctionNormalizer.

        Args:
            max_instruction (int): The maximum number of instructions to consider
                                   for each function.
        """
        self.max_instructions = max_instruction

    def normalize(self, f):
        """
        Normalize a single function representation.

        Args:
            f (list or np.array): The function representation to normalize.

        Returns:
            tuple: A tuple containing:
                - np.array: The normalized function representation.
                - int: The original length of the function (before padding).
        """
        f = np.asarray(f[0 : self.max_instructions])
        length = f.shape[0]
        if f.shape[0] < self.max_instructions:
            f = np.pad(f, (0, self.max_instructions - f.shape[0]), mode="constant")
        return f, length

    def normalize_function_pairs(self, pairs):
        """
        Normalize pairs of function representations.

        Args:
            pairs (list): A list of tuples, where each tuple contains two function
                          representations to be normalized.

        Returns:
            tuple: A tuple containing:
                - list: Normalized function pairs.
                - list: Original lengths of each function in the pairs.
        """
        lengths = []
        new_pairs = []
        for x in pairs:
            f0, len0 = self.normalize(x[0])
            f1, len1 = self.normalize(x[1])
            lengths.append((len0, len1))
            new_pairs.append((f0, f1))
        return new_pairs, lengths

    def normalize_functions(self, functions):
        """
        Normalize a list of function representations.

        Args:
            functions (list): A list of function representations to be normalized.

        Returns:
            tuple: A tuple containing:
                - list: Normalized function representations.
                - list: Original lengths of each function.
        """
        lengths = []
        new_functions = []
        for f in functions:
            f, length = self.normalize(f)
            lengths.append(length)
            new_functions.append(f)
        return new_functions, lengths
