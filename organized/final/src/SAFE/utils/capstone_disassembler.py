# @inproceedings{massarelli2018safe,
#   title={SAFE: Self-Attentive Function Embeddings for Binary Similarity},
#   author={Massarelli, Luca and Di Luna, Giuseppe Antonio and Petroni, Fabio and Querzoni, Leonardo and Baldoni, Roberto},
#   booktitle={Proceedings of 16th Conference on Detection of Intrusions and Malware & Vulnerability Assessment (DIMVA)},
#   year={2019}
# }

import capstone
import binascii

def filter_memory_references(i):
    inst = "" + i.mnemonic
    for op in i.operands:
        if op.type == 1:
            if i.reg_name(op.reg) is None:
                inst = inst + " "
            else:
                inst = inst + " " + i.reg_name(op.reg)
        elif op.type == 2:
            imm = int(op.imm)
            if -int(5000) <= imm <= int(5000):
                inst = inst + " " + str(hex(op.imm))
            else:
                inst = inst + " " + str("HIMM")
        elif op.type == 3:
            mem = op.mem
            if mem.base == 0:
                r = "[" + "MEM" + "]"
            else:
                r = (
                    "["
                    + str(i.reg_name(mem.base))
                    + "*"
                    + str(mem.scale)
                    + "+"
                    + str(mem.disp)
                    + "]"
                )
                inst = inst + " " + r
        if len(i.operands) > 1:
            inst = inst + ","
    if "," in inst:
        inst = inst[:-1]
    inst = inst.replace(" ", "_")
    return str(inst)


def disassemble(asm, arch, bits, verbose=False):
    binary = binascii.unhexlify(asm)

    if arch == "x86":
        cs_arch = capstone.CS_ARCH_X86
        if bits == 32:
            cs_bits = capstone.CS_MODE_32
        else:
            cs_bits = capstone.CS_MODE_64
            
    elif arch == "arm":
        cs_arch = capstone.CS_ARCH_ARM
        cs_bits = capstone.CS_MODE_ARM
        
    elif arch == "mips":
        cs_arch = capstone.CS_ARCH_MIPS
        if bits == 32:
            cs_bits = capstone.CS_MODE_MIPS32
        else:
            cs_bits = capstone.CS_MODE_MIPS64
            
    elif arch == "ppc":
        cs_arch = capstone.CS_ARCH_PPC
        if bits == 32:
            cs_bits = capstone.CS_MODE_32
        else:
            cs_bits = capstone.CS_MODE_64
        
    else:
        if verbose:
            print("Architecture not supported")
        return []

    md = capstone.Cs(cs_arch, cs_bits)
    md.detail = True
    instructions = []

    for i in md.disasm(binary, 0):
        instructions.append("X_" + filter_memory_references(i))

    return instructions
