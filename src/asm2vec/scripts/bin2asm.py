# Copyright (c) 2021 oalieno

#!/usr/bin/env python3
import re
import os
import sys
import r2pipe
import hashlib
from pathlib import Path
from malwareDetector.config import read_config

def sha3(data):
    """
    Compute the SHA3-256 hash of the given data, to be used as a unique identifier.

    Args:
        data (str): The input data to hash.

    Returns:
        str: The hexadecimal representation of the SHA3-256 hash.
    """
    return hashlib.sha3_256(data.encode()).hexdigest()

def validEXE(filename):
    """
    Check if the given file is a valid ELF executable.

    Args:
        filename (str): Path to the file to check.

    Returns:
        bool: True if the file is a valid ELF executable, False otherwise.
    """
    magics = [bytes.fromhex('7f454c46')]
    with open(filename, 'rb') as f:
        header = f.read(4)
        return header in magics

def normalize(opcode):
    """
    Normalize the given opcode by replacing constants and standardizing syntax.

    Args:
        opcode (str): The opcode to normalize.

    Returns:
        str: The normalized opcode.
    """
    opcode = opcode.replace(' - ', ' + ')
    opcode = re.sub(r'0x[0-9a-f]+', 'CONST', opcode)
    opcode = re.sub(r'\*[0-9]', '*CONST', opcode)
    opcode = re.sub(r' [0-9]', ' CONST', opcode)
    return opcode

def fn2asm(pdf, minlen):
    """
    Convert a function's PDF (Print Disassemble Function) output to normalized assembly.

    Args:
        pdf (dict): The PDF output from radare2.
        minlen (int): Minimum number of instructions required for a valid function.

    Returns:
        str: Normalized assembly code for the function, or None if invalid.
    """
    # check
    if pdf is None:
        return
    if len(pdf['ops']) < minlen:
        return
    if 'invalid' in [op['type'] for op in pdf['ops']]:
        return

    ops = pdf['ops']

    # set label
    labels, scope = {}, [op['offset'] for op in ops]
    assert(None not in scope)
    for i, op in enumerate(ops):
        if op.get('jump') in scope:
            labels.setdefault(op.get('jump'), i)
    
    # dump output
    output = ''
    for op in ops:
        # add label
        if labels.get(op.get('offset')) is not None:
            output += f'LABEL{labels[op["offset"]]}:\n'
        # add instruction
        if labels.get(op.get('jump')) is not None:
            output += f' {op["type"]} LABEL{labels[op["jump"]]}\n'
        else:
            output += f' {normalize(op["opcode"])}\n'

    return output

def bin2asm(filename, opath, minlen):
    """
    Extract assembly functions from a binary file.

    Args:
        filename (Path): Path to the binary file.
        opath (Path): Output directory path.
        minlen (int): Minimum number of instructions required for a valid function.

    Returns:
        int: Number of functions extracted.
    """
    # check
    if not validEXE(filename):
        return 0
    
    os.makedirs(opath / filename.name, exist_ok=True)

    r = r2pipe.open(str(filename))
    r.cmd('aaaa')

    count = 0

    for fn in r.cmdj('aflj'):
        r.cmd(f's {fn["offset"]}')
        asm = fn2asm(r.cmdj('pdfj'), minlen)
        if asm:
            uid = sha3(asm)
            asm = f''' .name {fn["name"]}
 .offset {hex(fn["offset"])}
 .file {filename.name}
''' + asm
            with open(opath / filename.name / uid, 'w') as f:
                f.write(asm)
                count += 1

    print(f'[+] {filename}')

    return count


def cli(ipath, opath, minlen):
    """
    Extracting assembly functions from binary executables.

    Args:
        ipath (str): Input path (file or directory) containing binary executables.
        opath (str): Output directory path for extracted assembly functions.
        minlen (int): Minimum number of instructions required for a valid function.
    """
    ipath = Path(ipath)
    opath = Path(opath)

    # create output directory
    os.makedirs(opath, exist_ok=True)

    fcount, bcount = 0, 0

    # directory
    if os.path.isdir(ipath):
        for f in os.listdir(ipath):
            if not os.path.islink(ipath / f) and not os.path.isdir(ipath / f):
                fcount += bin2asm(ipath / f, opath, minlen)
                bcount += 1
    # file
    elif os.path.exists(ipath):
        fcount += bin2asm(ipath, opath, minlen)
        bcount += 1
    else:
        print(f'[Error] No such file or directory: {ipath}')

    print(f'[+] Total scan binary: {bcount} => Total generated assembly functions: {fcount}')

if __name__ == '__main__':
    if len(sys.argv) < 2:
        raise ValueError('Please provide a config')
    
    config_path = sys.argv[1]
    sys.argv = [sys.argv[0]] # Clear the sys.argv
    config = read_config(config_path)
    dataset = config.folder.dataset
    opath = config.folder.feature
    
    for file in os.listdir(dataset):
        if os.path.exists(config.folder.feature + file):
                print(f'{file} already extracted')
                continue
        else:
            data = os.path.join(dataset, file)
            cli(data, opath, 3)
