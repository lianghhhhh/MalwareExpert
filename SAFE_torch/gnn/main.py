import torch
import torch.nn as nn
import torch.optim as optim
import torch_geometric
import torch_geometric.data
from model import MalwareExpert
from utils import load_data
from train import train
import time
from torch_geometric.explain import Explainer, GNNExplainer, ModelConfig

#load data
feature_matrix, edge_index, label, name = load_data()

#construct the data
x = [torch.tensor(feature_matrix[i], dtype=torch.float) for i in range(len(feature_matrix))]
edge_index = [torch.tensor(edge_index[i], dtype=torch.long) for i in range(len(edge_index))]
y = [torch.tensor(label[i], dtype=torch.long) for i in range(len(label))]
all_data = [torch_geometric.data.Data(x=x[i], edge_index=edge_index[i], y=y[i], name=name[i]) for i in range(len(x))]
#train 0.8, val 0.2
train_data = all_data[:int(len(all_data)*0.8)]
val_data = all_data[int(len(all_data)*0.8):]
print(all_data)
print(train_data)
print(val_data)

#data loader
#batch the data
#use pad_sequence to pad the data
#use DataLoader to batch the data
#use DataLoader to shuffle the data
#all_data = pad_sequence(all_data, batch_first=True, padding_value=0)
#print(all_data)
train_data = torch_geometric.data.Batch.from_data_list(train_data)
print(train_data)
train_data = torch_geometric.loader.DataLoader(train_data, batch_size=32, shuffle=True)
print(train_data)

val_data = torch_geometric.data.Batch.from_data_list(val_data)
print(val_data)
val_data = torch_geometric.loader.DataLoader(val_data, batch_size=32, shuffle=True)
print(val_data)


#construct the model
model = MalwareExpert(
    input_dim=100,
    hidden_dim=100
)

#construct the loss function
criterion = nn.CrossEntropyLoss()

#construct the optimizer
optimizer = optim.Adam(model.parameters(), lr=0.01)

#train the model
for epoch in range(100):
    start = time.time()
    loss = train(model, train_data, criterion, optimizer, epoch)
    spend_time = time.time() - start
    print('time: ', spend_time)

#save the model
torch.save(model.state_dict(), 'model.pth')

#load the model
model = MalwareExpert(100, 100)
model.load_state_dict(torch.load('model.pth'))
model.eval()

#test the model
correct = 0
total = 0
with torch.no_grad():
    for data in val_data:
        outputs = model(data.x, data.edge_index, data)
        _, predicted = torch.max(outputs.data, 1) 
        total += data.y.size(0)
        correct += (predicted == data.y).sum().item()
        print("data name: ", data.name, " label: ", data.y, " predicted: ", predicted)
print('Accuracy of the network on the test data: %d %%' % (100 * correct / total))


#use GNNExplainer to explain the model
explainer = Explainer(
    model=model,
    algorithm=GNNExplainer(epochs=100),
    explanation_type='model',
    node_mask_type='attributes',
    edge_mask_type='object',
    model_config=ModelConfig(
        mode='binary_classification',
        task_level='graph',
        return_type='probs'
    )
)

for data in val_data:
    explanation = explainer(
    x=data.x,
    edge_index=data.edge_index,
    data=data
    )
    #print the explanation and visualize the graph
    print(explanation)
    explanation.visualize_graph(path='graph.png')
    G = explanation.get_explanation_subgraph()
    print(G)
    G.visualize_graph(path='subgraph.png')


